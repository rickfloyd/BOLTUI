{"version":3,"sources":["turbopack:///[project]/src/app/animation/page.tsx","turbopack:///[project]/src/components/animation/GlobeAnimation.tsx"],"sourcesContent":["'use client';\n\nimport { useEffect } from 'react';\nimport GlobeAnimation from '@/components/animation/GlobeAnimation';\n\nexport default function AnimationPage() {\n  useEffect(() => {\n    document.body.classList.add('animation-page');\n    // Cleanup function to remove the class when the component unmounts\n    return () => {\n      document.body.classList.remove('animation-page');\n    };\n  }, []);\n\n  return <GlobeAnimation />;\n}\n","'use client';\n\nimport { useRef, useEffect } from 'react';\nimport * as THREE from 'three';\n\nconst GlobeAnimation = () => {\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (typeof window === 'undefined' || !containerRef.current) {\n      return;\n    }\n\n    const scene = new THREE.Scene();\n    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    const clock = new THREE.Clock();\n\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    containerRef.current.appendChild(renderer.domElement);\n\n    const uniforms = {\n      u_time: { type: 'f', value: 1.0 },\n      u_resolution: { type: 'v2', value: new THREE.Vector2() },\n      u_mouse: { type: 'v2', value: new THREE.Vector2() },\n    };\n\n    const geometry = new THREE.SphereGeometry(15, 64, 64);\n    const material = new THREE.ShaderMaterial({\n      uniforms: uniforms,\n      vertexShader: `\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      `,\n      fragmentShader: `\n        varying vec2 vUv;\n        uniform float u_time;\n\n        // 2D Random\n        float random (vec2 st) {\n            return fract(sin(dot(st.xy,\n                                 vec2(12.9898,78.233)))*\n                43758.5453123);\n        }\n        \n        // 2D Noise\n        float noise (in vec2 st) {\n            vec2 i = floor(st);\n            vec2 f = fract(st);\n\n            // Four corners in 2D of a tile\n            float a = random(i);\n            float b = random(i + vec2(1.0, 0.0));\n            float c = random(i + vec2(0.0, 1.0));\n            float d = random(i + vec2(1.0, 1.0));\n\n            vec2 u = f * f * (3.0 - 2.0 * f);\n\n            return mix(a, b, u.x) +\n                    (c - a)* u.y * (1.0 - u.x) +\n                    (d - b) * u.x * u.y;\n        }\n\n\n        void main() {\n            vec2 st = vUv * 3.0; // Scale UV\n            st.x += u_time * 0.05; // Horizontal movement\n\n            // Use noise to create organic patterns\n            float n = noise(st * 1.5 + u_time * 0.1);\n\n            // Define the three colors\n            vec3 color1 = vec3(1.0, 0.078, 0.576); // Hot Pink\n            vec3 color2 = vec3(1.0, 0.4, 0.0);   // Fluorescent Orange (adjusted for more vibrancy)\n            vec3 color3 = vec3(0.0, 0.8, 1.0);     // Neon Blue/Cyan (adjusted)\n            \n            // Create a smoothly varying factor for mixing\n            float mixFactor1 = 0.5 + 0.5 * sin(st.y * 2.0 + u_time * 0.3 + n * 2.0);\n            float mixFactor2 = 0.5 + 0.5 * cos(st.x * 2.0 - u_time * 0.2 + n * 2.0);\n\n            // Mix the colors in a fluid way\n            vec3 finalColor = mix(color1, color2, mixFactor1);\n            finalColor = mix(finalColor, color3, mixFactor2);\n            finalColor *= (0.8 + n * 0.2); // Add some subtle brightness variations\n\n            gl_FragColor = vec4(finalColor, 1.0);\n        }\n      `,\n    });\n    const sphere = new THREE.Mesh(geometry, material);\n    scene.add(sphere);\n\n    camera.position.z = 30;\n\n    const animate = () => {\n      requestAnimationFrame(animate);\n      uniforms.u_time.value = clock.getElapsedTime();\n      sphere.rotation.y += 0.0005;\n      renderer.render(scene, camera);\n    };\n\n    animate();\n\n    const handleResize = () => {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      if (containerRef.current) {\n        containerRef.current.removeChild(renderer.domElement);\n      }\n    };\n  }, []);\n\n  return (\n    <>\n      <div id=\"animation-container\" ref={containerRef}></div>\n      <div id=\"title-overlay\">AI QUANTUM CHARTS</div>\n    </>\n  );\n};\n\nexport default GlobeAnimation;\n"],"names":[],"mappings":"uDAEA,EAAA,EAAA,CAAA,CAAA,aCGuB,KACrB,IAAM,EAAe,CAAA,EAAA,EAAA,MAAA,AAAM,EAAiB,MAoH5C,CAQa,KA1Hb,CAAA,EAAA,EAAA,SAAA,AAAS,EAAC,KAgHV,EAAG,EAAE,EAGH,CAAA,EAAA,EAAA,IAAA,EAAA,EAAA,QAAA,CAAA,WACE,CAAA,EAAA,EAAA,GAAA,EAAC,MAAA,CAAI,GAAG,sBAAsB,IAAK,IACnC,CAAA,EAAA,EAAA,GAAA,EAAC,MAAA,CAAI,GAAG,yBAAgB,wBAG9B,ED3He,SAAS,IAStB,MARA,CAAA,EAAA,EAAA,SAAA,AAAS,EAAC,KACR,SAAS,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,kBAErB,KACL,SAAS,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,iBACjC,GACC,EAAE,EAEE,CAAA,EAAA,EAAA,GAAA,EAAC,EAAA,CAAA,EACV"}